import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Setup your front end

## Deep linking

When we send out a passkey email, the link will redirect to your application specified by the Authenticator Config's [Invoke URL](../platform-overview/authenticator-config#invoke-url). This URI should either be an app scheme or a Universal URL / App link.

:::caution
While app schemes are generally easier to set up, Universal URLs and App Links are recommended as they provide protection against App Scheme hijacking.
:::

<Tabs groupId="bind-platform">
<TabItem value="kotlin" label="Kotlin">

Android supports two ways of deep linking into an application. Pick one of the following and follow the guide:

- [Custom Schemes](https://developer.android.com/training/basics/intents/filters)
- [App Links](https://developer.android.com/training/app-links)

</TabItem>
<TabItem value="swift" label="Swift">

Apple supports two ways of deep linking into an application. Pick one of the following and follow the guide:

- [App Schemes](https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app)
- [Universal URLs](https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html)

</TabItem>
<TabItem value="reactnative" label="React Native">

If you are using Expo, follow the [deep linking guide](https://docs.expo.dev/guides/deep-linking/).

If you are using a `bare expo` or `react-native init` project, follow the Kotlin and Swift guides to setting up deep linking on React Native.

Also check out [React Native Linking](https://reactnative.dev/docs/linking):

```javascript
import { useEffect, useState } from 'react';
import { Linking } from 'react-native';

export default function useDeepLinkURL() {
  const [linkedURL, setLinkedURL] = (useState < string) | (null > null);

  // If the app is not already open
  useEffect(() => {
    const getUrlAsync = async () => {
      const initialUrl = await Linking.getInitialURL();
      if (initialUrl !== null) {
        setLinkedURL(decodeURI(initialUrl));
      }
    };

    getUrlAsync();
  }, []);

  // If the app is already open
  useEffect(() => {
    const callback = ({ url }: { url: string }) => setLinkedURL(decodeURI(url));
    const linkingEventListener = Linking.addEventListener('url', callback);
    return () => {
      linkingEventListener.remove();
    };
  }, []);

  return { linkedURL };
}

// in App.js
const { linkedURL } = useDeepLinkURL();

useEffect(() => {
  async function register() {
    if (linkedURL !== null) {
      console.log('intercepted:', linkedURL);
    }
  }

  register();
}, [linkedURL]);
```

</TabItem>
<TabItem value="flutter" label="Flutter">
Follow the Kotlin and Swift guides to setting up deep linking on Flutter.

</TabItem>
</Tabs>

## Handle link in the SDK

Once you have the incoming URL, pass it into the SDK to complete the binding process. Upon success, a private key will have been created in the device's hardware trust module and the corresponding public key will have been sent to the Beyond Identity Cloud. At this point the user has a passkey enrolled on this device. Don't forget to initalize your SDK ahead of time. For more information see [SDK Setup](./sdk-setup).

<Tabs groupId="bind-platform">
<TabItem value="javascript" label="Javascript">

You can validate the incoming URL with `isBindPasskeyUrl`. When the URL is intercepted, pass it to `bindPasskey`.

```javascript
cons isBindUrl = await embedded.isBindPasskeyUrl(bindingLink)

if (isBindUrl){
    const bindResponse = await embedded.bindPasskey(bindingLink);
    console.log(bindResponse);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

You can validate the incoming URL with `isBindPasskeyUrl`. When the URL is intercepted, pass it to `bindPasskey`.

```kotlin
if (EmbeddedSdk.isBindPasskeyUrl(url)) {
    EmbeddedSdk.bindPasskey(url = bindingLink)
    .onEach { result ->
        result.onSuccess { success ->
            Timber.d("Bind Passkey success = $success")
        }
        result.onFailure { failure ->
            Timber.e("Bind Passkey failure = $failure")
        }
    }
}
```

</TabItem>
<TabItem value="swift" label="Swift">

Catch a url from your AppDelegate or SceneDelegate. You can validate the incoming URL with `isBindPasskeyUrl`. When the URL is intercepted, pass it to `bindPasskey`.

```swift
func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
    if let url = URLContexts.first?.url, Embedded.shared.isBindPasskeyUrl(url) {
        Embedded.shared.bindPasskey(url: bindingLink) { result in
            switch result {
            case let .success(bindResponse):
                print(bindResponse)
            case let .failure(error):
                print(error.localizedDescription)
            }
        }
    }
}
```

</TabItem>
<TabItem value="reactnative" label="React Native">

You can validate the incoming URL with `isBindPasskeyUrl`. When the URL is intercepted, pass it to `bindPasskey`.

```javascript
const isBindUrl = await Embedded.isBindPasskeyUrl(url);
if (isBindUrl) {
  const bindResponse = await Embedded.bindPasskey(bindingLink);
  console.log(bindResponse);
}
```

</TabItem>
<TabItem value="flutter" label="Flutter">

You can validate the incoming URL with `isBindPasskeyUrl`. When the URL is intercepted, pass it to `bindPasskey`.

```dart
bool isBindUrl = await EmbeddedSdk.isBindPasskeyUrl(bindingLink);

if (isBindUrl) {
    BindPasskeyResponse bindResponse = await EmbeddedSdk.bindPasskey(bindingLink);
    debugPrint(bindResponse);
}
```

</TabItem>
</Tabs>
